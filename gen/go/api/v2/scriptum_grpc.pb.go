// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: api/v2/scriptum.proto

package apiv2

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FileService_Upload_FullMethodName = "/api.v2.FileService/Upload"
)

// FileServiceClient is the client API for FileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileServiceClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileUploadRequest, FileUploadResponse], error)
}

type fileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileServiceClient(cc grpc.ClientConnInterface) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) Upload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileUploadRequest, FileUploadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FileService_ServiceDesc.Streams[0], FileService_Upload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileUploadRequest, FileUploadResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FileService_UploadClient = grpc.ClientStreamingClient[FileUploadRequest, FileUploadResponse]

// FileServiceServer is the server API for FileService service.
// All implementations must embed UnimplementedFileServiceServer
// for forward compatibility.
type FileServiceServer interface {
	Upload(grpc.ClientStreamingServer[FileUploadRequest, FileUploadResponse]) error
	mustEmbedUnimplementedFileServiceServer()
}

// UnimplementedFileServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFileServiceServer struct{}

func (UnimplementedFileServiceServer) Upload(grpc.ClientStreamingServer[FileUploadRequest, FileUploadResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedFileServiceServer) mustEmbedUnimplementedFileServiceServer() {}
func (UnimplementedFileServiceServer) testEmbeddedByValue()                     {}

// UnsafeFileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileServiceServer will
// result in compilation errors.
type UnsafeFileServiceServer interface {
	mustEmbedUnimplementedFileServiceServer()
}

func RegisterFileServiceServer(s grpc.ServiceRegistrar, srv FileServiceServer) {
	// If the following call pancis, it indicates UnimplementedFileServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FileService_ServiceDesc, srv)
}

func _FileService_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileServiceServer).Upload(&grpc.GenericServerStream[FileUploadRequest, FileUploadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FileService_UploadServer = grpc.ClientStreamingServer[FileUploadRequest, FileUploadResponse]

// FileService_ServiceDesc is the grpc.ServiceDesc for FileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v2.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _FileService_Upload_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api/v2/scriptum.proto",
}

const (
	BoxService_CreateBox_FullMethodName   = "/api.v2.BoxService/CreateBox"
	BoxService_DeleteBox_FullMethodName   = "/api.v2.BoxService/DeleteBox"
	BoxService_GetBox_FullMethodName      = "/api.v2.BoxService/GetBox"
	BoxService_GetBoxes_FullMethodName    = "/api.v2.BoxService/GetBoxes"
	BoxService_SearchBoxes_FullMethodName = "/api.v2.BoxService/SearchBoxes"
	BoxService_StartJob_FullMethodName    = "/api.v2.BoxService/StartJob"
)

// BoxServiceClient is the client API for BoxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BoxServiceClient interface {
	CreateBox(ctx context.Context, in *CreateBoxRequest, opts ...grpc.CallOption) (*CreateBoxResponse, error)
	DeleteBox(ctx context.Context, in *DeleteBoxRequest, opts ...grpc.CallOption) (*DeleteBoxResponse, error)
	GetBox(ctx context.Context, in *GetBoxRequest, opts ...grpc.CallOption) (*GetBoxResponse, error)
	GetBoxes(ctx context.Context, in *GetBoxesRequest, opts ...grpc.CallOption) (*GetBoxesResponse, error)
	SearchBoxes(ctx context.Context, in *SearchBoxesRequest, opts ...grpc.CallOption) (*SearchBoxesResponse, error)
	StartJob(ctx context.Context, in *StartJobRequest, opts ...grpc.CallOption) (*StartJobResponse, error)
}

type boxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBoxServiceClient(cc grpc.ClientConnInterface) BoxServiceClient {
	return &boxServiceClient{cc}
}

func (c *boxServiceClient) CreateBox(ctx context.Context, in *CreateBoxRequest, opts ...grpc.CallOption) (*CreateBoxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBoxResponse)
	err := c.cc.Invoke(ctx, BoxService_CreateBox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) DeleteBox(ctx context.Context, in *DeleteBoxRequest, opts ...grpc.CallOption) (*DeleteBoxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteBoxResponse)
	err := c.cc.Invoke(ctx, BoxService_DeleteBox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) GetBox(ctx context.Context, in *GetBoxRequest, opts ...grpc.CallOption) (*GetBoxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBoxResponse)
	err := c.cc.Invoke(ctx, BoxService_GetBox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) GetBoxes(ctx context.Context, in *GetBoxesRequest, opts ...grpc.CallOption) (*GetBoxesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBoxesResponse)
	err := c.cc.Invoke(ctx, BoxService_GetBoxes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) SearchBoxes(ctx context.Context, in *SearchBoxesRequest, opts ...grpc.CallOption) (*SearchBoxesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchBoxesResponse)
	err := c.cc.Invoke(ctx, BoxService_SearchBoxes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) StartJob(ctx context.Context, in *StartJobRequest, opts ...grpc.CallOption) (*StartJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartJobResponse)
	err := c.cc.Invoke(ctx, BoxService_StartJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoxServiceServer is the server API for BoxService service.
// All implementations must embed UnimplementedBoxServiceServer
// for forward compatibility.
type BoxServiceServer interface {
	CreateBox(context.Context, *CreateBoxRequest) (*CreateBoxResponse, error)
	DeleteBox(context.Context, *DeleteBoxRequest) (*DeleteBoxResponse, error)
	GetBox(context.Context, *GetBoxRequest) (*GetBoxResponse, error)
	GetBoxes(context.Context, *GetBoxesRequest) (*GetBoxesResponse, error)
	SearchBoxes(context.Context, *SearchBoxesRequest) (*SearchBoxesResponse, error)
	StartJob(context.Context, *StartJobRequest) (*StartJobResponse, error)
	mustEmbedUnimplementedBoxServiceServer()
}

// UnimplementedBoxServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBoxServiceServer struct{}

func (UnimplementedBoxServiceServer) CreateBox(context.Context, *CreateBoxRequest) (*CreateBoxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBox not implemented")
}
func (UnimplementedBoxServiceServer) DeleteBox(context.Context, *DeleteBoxRequest) (*DeleteBoxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBox not implemented")
}
func (UnimplementedBoxServiceServer) GetBox(context.Context, *GetBoxRequest) (*GetBoxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBox not implemented")
}
func (UnimplementedBoxServiceServer) GetBoxes(context.Context, *GetBoxesRequest) (*GetBoxesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBoxes not implemented")
}
func (UnimplementedBoxServiceServer) SearchBoxes(context.Context, *SearchBoxesRequest) (*SearchBoxesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBoxes not implemented")
}
func (UnimplementedBoxServiceServer) StartJob(context.Context, *StartJobRequest) (*StartJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartJob not implemented")
}
func (UnimplementedBoxServiceServer) mustEmbedUnimplementedBoxServiceServer() {}
func (UnimplementedBoxServiceServer) testEmbeddedByValue()                    {}

// UnsafeBoxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BoxServiceServer will
// result in compilation errors.
type UnsafeBoxServiceServer interface {
	mustEmbedUnimplementedBoxServiceServer()
}

func RegisterBoxServiceServer(s grpc.ServiceRegistrar, srv BoxServiceServer) {
	// If the following call pancis, it indicates UnimplementedBoxServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BoxService_ServiceDesc, srv)
}

func _BoxService_CreateBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).CreateBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoxService_CreateBox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).CreateBox(ctx, req.(*CreateBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_DeleteBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).DeleteBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoxService_DeleteBox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).DeleteBox(ctx, req.(*DeleteBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_GetBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).GetBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoxService_GetBox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).GetBox(ctx, req.(*GetBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_GetBoxes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBoxesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).GetBoxes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoxService_GetBoxes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).GetBoxes(ctx, req.(*GetBoxesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_SearchBoxes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBoxesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).SearchBoxes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoxService_SearchBoxes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).SearchBoxes(ctx, req.(*SearchBoxesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_StartJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).StartJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoxService_StartJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).StartJob(ctx, req.(*StartJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BoxService_ServiceDesc is the grpc.ServiceDesc for BoxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BoxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v2.BoxService",
	HandlerType: (*BoxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBox",
			Handler:    _BoxService_CreateBox_Handler,
		},
		{
			MethodName: "DeleteBox",
			Handler:    _BoxService_DeleteBox_Handler,
		},
		{
			MethodName: "GetBox",
			Handler:    _BoxService_GetBox_Handler,
		},
		{
			MethodName: "GetBoxes",
			Handler:    _BoxService_GetBoxes_Handler,
		},
		{
			MethodName: "SearchBoxes",
			Handler:    _BoxService_SearchBoxes_Handler,
		},
		{
			MethodName: "StartJob",
			Handler:    _BoxService_StartJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v2/scriptum.proto",
}

const (
	JobService_GetJob_FullMethodName  = "/api.v2.JobService/GetJob"
	JobService_GetJobs_FullMethodName = "/api.v2.JobService/GetJobs"
)

// JobServiceClient is the client API for JobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobServiceClient interface {
	GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error)
	GetJobs(ctx context.Context, in *GetJobsRequest, opts ...grpc.CallOption) (*GetJobsResponse, error)
}

type jobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobServiceClient(cc grpc.ClientConnInterface) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJobResponse)
	err := c.cc.Invoke(ctx, JobService_GetJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJobs(ctx context.Context, in *GetJobsRequest, opts ...grpc.CallOption) (*GetJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJobsResponse)
	err := c.cc.Invoke(ctx, JobService_GetJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobServiceServer is the server API for JobService service.
// All implementations must embed UnimplementedJobServiceServer
// for forward compatibility.
type JobServiceServer interface {
	GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error)
	GetJobs(context.Context, *GetJobsRequest) (*GetJobsResponse, error)
	mustEmbedUnimplementedJobServiceServer()
}

// UnimplementedJobServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJobServiceServer struct{}

func (UnimplementedJobServiceServer) GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedJobServiceServer) GetJobs(context.Context, *GetJobsRequest) (*GetJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobs not implemented")
}
func (UnimplementedJobServiceServer) mustEmbedUnimplementedJobServiceServer() {}
func (UnimplementedJobServiceServer) testEmbeddedByValue()                    {}

// UnsafeJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServiceServer will
// result in compilation errors.
type UnsafeJobServiceServer interface {
	mustEmbedUnimplementedJobServiceServer()
}

func RegisterJobServiceServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	// If the following call pancis, it indicates UnimplementedJobServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JobService_ServiceDesc, srv)
}

func _JobService_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetJob(ctx, req.(*GetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetJobs(ctx, req.(*GetJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JobService_ServiceDesc is the grpc.ServiceDesc for JobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v2.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJob",
			Handler:    _JobService_GetJob_Handler,
		},
		{
			MethodName: "GetJobs",
			Handler:    _JobService_GetJobs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v2/scriptum.proto",
}
